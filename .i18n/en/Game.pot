msgid ""
msgstr "Project-Id-Version: Game v4.7.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: Tue Dec 10 10:43:06 2024\n"
"Last-Translator: \n"
"Language-Team: none\n"
"Language: en\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit"

#: GameServer.RpcHandlers
msgid "level completed! üéâ"
msgstr ""

#: GameServer.RpcHandlers
msgid "level completed with warnings‚Ä¶ üé≠"
msgstr ""

#: GameServer.RpcHandlers
msgid "intermediate goal solved! üéâ"
msgstr ""

#: Game.Levels.Intro.L01_First
msgid ""
msgstr ""

#: Game.Levels.Intro.L01_First
msgid "## The setup\n"
"We note that the following description applies to the Desktop version of this website.\n"
"If you are using a mobile device, the layout may be different.\n"
"\n"
"You should see different windows on this page, they will contain part of using Lean.\n"
"Let's go through them one by one.\n"
"\n"
"The middle one is where you tell Lean what steps you want to make in your proof.\n"
"You can do this in 'Typewriter mode' or 'Editor mode'.\n"
"We suggest you click the `</>` button in the top right corner to switch to 'Editor mode',\n"
"which is closer to how Lean actually looks.\n"
"\n"
"By typing statements here in precise language we instruct Lean how we want the proof to go.\n"
"\n"
"At the bottom of the middle window, it reads `Current Goal`.\n"
"This panel represents what Lean thinks the current state of your proof is.\n"
"It also shows the objects you are working with and the assumptions that you currently have. The statement (or statements) you are trying to show come after\n"
"`Goal`.\n"
"For example, a valid state might look like\n"
"```\n"
"Objects:\n"
"n : ‚Ñï\n"
"Assumptions:\n"
"h : Even n\n"
"Goal:\n"
"Odd (n + 1)\n"
"```\n"
"which means that we have assumed `n` is a natural number and that `n` is even, and we are trying to show that `n + 1` is\n"
"odd (we sometimes write `‚ä¢` as a shorthand notation for `Goal`).\n"
"In order to prove this, we will need to use more than what is written here, however. We might need the definition of\n"
"an even and an odd number, so in addition to the current hypotheses we also will make use of a library of lemmas that\n"
"we have proved so far.\n"
"\n"
"Below this, there will be feedback about any errors in your current proof.\n"
"As you move your cursor around by clicking different parts of the proof the goal will update, we can\n"
"always step backwards and forwards through the proof using the arrow keys to check what we were\n"
"proving before.\n"
"If you write some syntax Lean doesn't understand, or a proof step that doesn't make sense, Lean will\n"
"return an error, the most common error being `unsolved goals`\n"
"which just means that you aren't finished with the proof yet!\n"
"\n"
"On the right of the screen, you will find a list of *Theorems* and *tactics* you can use to prove\n"
"results, this is here to remind you of the things we've talked about so far. You can click on them to see more info.\n"
"\n"
"## The language\n"
"\n"
"A lemma in Lean is written using a specific syntax, that is designed to look similar to written\n"
"mathematics, but is more restricted in how statements can be constructed.\n"
"Here is an example of a lemma statement in Lean:\n"
"\n"
"``` lemma add_comm : ‚àÄ (x : ‚Ñï) (y : ‚Ñï), x + y = y + x ```\n"
"\n"
"This lemma states that for all natural numbers `x` and `y` the addition of `x` and `y` commutes.\n"
"Hopefully, you agree that this is a straightforward, but very useful fact!\n"
"Note the first word `lemma` is a keyword and means we are stating a new\n"
"lemma.\n"
"The second word is simply a name we give to the lemma so we can refer to it later, naming lemmas\n"
"works much better than numbering lemmas when you need to refer back to many things.\n"
"This is especially helpful if you give the lemmas sensible names, so that you can remember them\n"
"later, and so that when you use them you can tell what the lemma does from its name.\n"
"In this case `add_comm` says that addition is commutative, so it seems like a pretty good choice.\n"
"\n"
"The symbol `:` is used to say that `x` and `y` are natural numbers, this is similar to how we\n"
"normally write `x ‚àà ‚Ñï`, and you should think of `:` as meaning `‚àà`.\n"
"The symbol `:` is also used after the name of the lemma, and it has the same meaning!\n"
"Here within the lemma `x : ‚Ñï` gives a name to a natural number and\n"
"`add_comm : ‚àÄ x y, x + y = y + x` gives a name to the statement that addition is commutative.\n"
"\n"
"The lemma `add_comm` is a 'for all' statement, so in order to get the statement that addition\n"
"commutes for a _specific_ pair of natural numbers rather than variables `x` and `y`,\n"
"we place the naturals we want to refer to after the name,\n"
"for instance `add_comm 2 3` means `2 + 3 = 3 + 2`.\n"
"Here we used 2 and 3, but we could apply this lemma with variables too by using their names\n"
"instead of 2 and 3.\n"
"\n"
"When you click on `add_comm` in the *Theorems* list on the right, you'll see that the\n"
"full name of the lemma is `Intro.add_comm`. The prefix before the dot is the namespace\n"
"where that lemma is contained. It is often the case, for example, when the relevant namespace of a lemma is open, that\n"
"the prefix before the dot can be omitted when typing it in Lean.\n"
"\n"
"### Rewriting\n"
"Rewriting is one of the most basic methods of proof. We substitute one object we know equals another\n"
"inside what we want to prove, by doing this we can get closer to something that we already know to\n"
"be true,\n"
"or get to a point where things cancel out or simplify.\n"
"\n"
"For example, if `h` is a name for the fact that `X = Y`, then `rewrite [h]` will change\n"
"all `X`s in the goal to `Y`s.\n"
"On the right-hand side in the tactics panel you can find more details about\n"
"`rewrite`, you don't need to read it now, but it's there if you ever want to check the syntax\n"
"again.\n"
"\n"
"### Reflexivity\n"
"A goal of the form `A = A` can be solved using the reflexivity tactic called `rfl`.\n"
"For example, if the goal is `x + y = x + y`, then `rfl` will solve it.\n"
"\n"
"Now try to use a sequence of `rewrite` steps to prove the lemma below by typing them into the box\n"
"on the right. To finish the proof, you can use `rfl`. We note the convention that `x + y + z` means `(x + y) + z`.\n"
"\n"
"It's worth noting that while this game introduces basic lemmas and tactics for proving\n"
"mathematical statements in Lean, Lean does have more advanced\n"
"automation tools that can solve certain goals in one go."
msgstr ""

#: Game.Levels.Intro.L01_First
msgid "Start by typing `rewrite [add_comm x y]`.\n"
"That is the first step of the proof. After typing it, you should see the goal (at the bottom)\n"
"change so the sides of the equation look closer to each other.\n"
"The next two steps of the proof go on the next lines, and are similar to the first, can you work\n"
"them out?\n"
"To finish the proof, you may want to use `rfl`."
msgstr ""

#: Game.Levels.Intro.L01_First
msgid "This tactic proves goals of the form `‚ä¢ A = A`"
msgstr ""

#: Game.Levels.Intro.L01_First
msgid "## Summary\n"
"\n"
"If `h` is a proof of `X = Y`, then `rewrite [h]` will change\n"
"all `X`s in the goal to `Y`s.\n"
"\n"
"As this is such a common proof step we also have a short name, `rw` instead of `rewrite` for this\n"
"step, to save us from too much typing.\n"
"\n"
"Variants: `rw [‚Üê h]` (type `‚Üê` using `\\l` for left) changes\n"
"`Y` to `X` and\n"
"`rw [h] at h2` changes `X` to `Y` in hypothesis `h2` instead\n"
"of the goal.\n"
"\n"
"## Details\n"
"\n"
"The `rw` tactic is a way to do 'substituting in'. There\n"
"are two distinct situations where to use these tactics.\n"
"\n"
"1) If `h : A = B` is a hypothesis (i.e., a proof of `A = B`)\n"
"in your local context\n"
"and if your goal contains one or more `A`s, then `rw [h]`\n"
"will change them all to `B`'s.\n"
"\n"
"2) The `rw` tactic will also work with proofs of theorems\n"
"which are equalities (look for them in the\n"
"menu on the right, within Theorems).\n"
"\n"
"Important note: if `h` is not a proof of the form `A = B`\n"
"or `A ‚Üî B` (for example if `h` is a function, an implication,\n"
"or perhaps even a proposition itself rather than its proof),\n"
"then `rw` is not the tactic you want to use. For example,\n"
"`rw (P = Q)` is never correct: `P = Q` is the true-false\n"
"statement itself, not the proof.\n"
"If `h : P = Q` is its proof, then `rw [h]` will work.\n"
"\n"
"Pro tip 1: If `h : A = B` and you want to change\n"
"`B`s to `A`s instead, try `rw [‚Üê h]` (get the arrow with `\\l`,\n"
"note that this is a small letter L, not a number 1).\n"
"\n"
"### Example:\n"
"If it looks like this in the bottom box:\n"
"```\n"
"Objects:\n"
"A B C : set X\n"
"Assumptions:\n"
"h : A = B ‚à™ C\n"
"Goal:\n"
"  A ‚à™ B = B ‚à™ C\n"
"```\n"
"\n"
"then\n"
"\n"
"`rw [h]`\n"
"\n"
"will change the goal into ` ‚ä¢ B ‚à™ C ‚à™ B = B ‚à™ C`.\n"
"\n"
"### Example:\n"
"You can use `rw` to change a hypothesis as well.\n"
"For example, if your local context looks like this:\n"
"```\n"
"Objects:\n"
"A B C D : set X\n"
"Assumptions:\n"
"h1 : A = B ‚à© C\n"
"h2 : B ‚à™ A = D\n"
"Goal:\n"
"  D = B\n"
"```\n"
"then `rw [h1] at h2` will turn `h2` into `h2 : B ‚à™ B ‚à© C = D` (remember operator precedence)."
msgstr ""

#: Game.Levels.Intro.L02_Two
msgid ""
msgstr ""

#: Game.Levels.Intro.L02_Two
msgid "We can state lemmas assuming hypotheses with similar notation as we made a lemma\n"
"dependent on natural numbers before.\n"
"\n"
"The `rewrite` tactic can then be used to rewrite a hypothesis. After all, we can substitute\n"
"things we know to be equal in facts we know, as well as substituting into what we are trying to prove.\n"
"\n"
"### Example:\n"
"You can use `rewrite` to change a hypothesis as well.\n"
"For example, if your goal state looks like this:\n"
"```\n"
"Objects:\n"
"n m : ‚Ñï\n"
"Assumptions:\n"
"h1 : n + 1 = 7\n"
"h2 : m = n + 1\n"
"Goal:\n"
"m + 2 = 9\n"
"```\n"
"then `rewrite [h1] at h2` will turn `h2` into `h2 : m = 7`.\n"
"\n"
"Below are two useful results you can use to finish this level.\n"
"\n"
"\n"
"``` lemma add_zero : ‚àÄ x, x + 0 = x ```\n"
"\n"
"``` lemma one_mul : ‚àÄ x, 1 * x = x ```"
msgstr ""

#: Game.Levels.Intro.L02_Two
msgid "Type `rewrite [add_zero x] at hx` as a first step of the proof.\n"
"In fact, in this situation the `rewrite` tactic can infer that the argument of `add_zero` should be `x`,\n"
"so one could leave out the argument `x`, i.e. simply write `rewrite [add_zero] at hx`."
msgstr ""

#: Game.Levels.Intro.L03_Three
msgid ""
msgstr ""

#: Game.Levels.Intro.L03_Three
msgid "So far we've worked with numbers in Lean and seen how we can substitute equalities\n"
"of natural numbers using `rewrite`.\n"
"In Lean, we don't just work with objects like numbers, but we can also manipulate and prove things\n"
"that are far more abstract and deal with propositions themselves as objects we want to prove things about.\n"
"\n"
"In Lean, these are called *propositions* and denoted `P : Prop`, exactly the same as how we had `n : ‚Ñï`\n"
"before.\n"
"A proposition itself is a statement we might be trying to prove or disprove, but we can use the\n"
"same tool we used so far, rewriting, to manipulate them.\n"
"When dealing with concrete objects like numbers, we substitute equal numbers when proving.\n"
"For propositions, we can substitute equivalent propositions, where propositions are equivalent\n"
"if they are related by an 'if and only if'. For instance, one simple fact is that\n"
"\n"
"``` lemma or_comm : ‚àÄ (P Q : Prop), P ‚à® Q ‚Üî Q ‚à® P ```\n"
"\n"
"So if we wanted to show `‚ä¢ x = 2 ‚à® y = 1` we could `rewrite [or_comm]` to change the goal to\n"
"`‚ä¢ y = 1 ‚à® x = 2`, which might then match one of our hypotheses better.\n"
"\n"
"Check out the right sidebar for some new lemmas that you can use to prove the statement below.\n"
"If you click on the `not_not` lemma in the right sidebar, you will notice the curly (instead of round) brackets used in `{a : Prop}`.\n"
"This signals that `a` is a so-called implicit argument to `not_not`, meaning that syntax like `rewrite [not_not a]` is not correct,\n"
"and instead `rewrite [not_not]` should be used (where the argument `a` is then inferred automatically)."
msgstr ""

#: Game.Levels.Intro.L03_Three
msgid "Now use `rfl`. This tactic also works for proving goals of the form `P ‚Üî P`."
msgstr ""

#: Game.Levels.Intro.L03_Three
msgid "Undo the last move and try `rfl`."
msgstr ""

#: Game.Levels.Intro.L04_Four
msgid ""
msgstr ""

#: Game.Levels.Intro.L04_Four
msgid "## Exact\n"
"\n"
"Sometimes after rewriting the hypotheses and goal enough, we reach a point where the goal is\n"
"exactly the same as one of the hypotheses.\n"
"In this case, we want to tell Lean that we are finished, one of our hypotheses now matches\n"
"the conclusion we needed to get to.\n"
"\n"
"The tactic to do this is called `exact`, and to use it we just need to supply the name of\n"
"the hypothesis we want to use.\n"
"\n"
"For example, if we were trying to prove that 3 divides some natural number `n` and we\n"
"ended up with the goal state:\n"
"```\n"
"Objects:\n"
"n : ‚Ñï\n"
"Assumptions:\n"
"h : 3 ‚à£ n\n"
"Goal:\n"
"3 ‚à£ n\n"
"```\n"
"then `exact h` would complete the proof.\n"
"\n"
"\n"
"We note that binary logical connectives like `‚àß` and `‚à®` associate to the right, so\n"
"`Q ‚àß P ‚àß Q` means `Q ‚àß (P ‚àß Q)`."
msgstr ""

#: Game.Levels.Intro.L04_Four
msgid "## Summary\n"
"\n"
"If the goal is `‚ä¢ X` then `exact x` will close the goal if\n"
"and only if `x` is a term of type `X`.\n"
"\n"
"## Details\n"
"\n"
"Say $P$, $Q$ and $R$ are types (i.e., what a mathematician\n"
"might think of as either sets or propositions),\n"
"and the local context looks like this:\n"
"\n"
"```\n"
"Objects and Assumptions\n"
"p : P,\n"
"h : P ‚Üí Q,\n"
"j : Q ‚Üí R\n"
"Goal:\n"
"R\n"
"```\n"
"\n"
"If you can spot how to make a term of type `R`, then you\n"
"can just make it and say you're done using the `exact` tactic\n"
"together with the formula you have spotted. For example, the\n"
"above goal could be solved with\n"
"\n"
"`exact j(h(p)),`\n"
"\n"
"because $j(h(p))$ is easily checked to be a term of type $R$\n"
"(i.e., an element of the set $R$, or a proof of the proposition $R$)."
msgstr ""

#: Game.Levels.Intro
msgid "Intro"
msgstr ""

#: Game.Levels.Intro
msgid "Welcome to Lean! In this Introduction World you will learn some of the basics.\n"
"We strongly encourage you to carefully read the explanations in this panel.\n"
"Click `Start` to begin."
msgstr ""

#: Game.Levels.Intermediate.L01_First
msgid "In this level we introduce the tactic `intro`. You will need it to get started.\n"
"  Please click on the `intro` tactic in the right sidebar to read an explanation."
msgstr ""

#: Game.Levels.Intermediate.L01_First
msgid "Try something like `intro h1` and go from there."
msgstr ""

#: Game.Levels.Intermediate.L01_First
msgid "## Summary:\n"
"\n"
"`intro p` will turn a goal `‚ä¢ P ‚Üí Q` into a hypothesis `p : P`\n"
"and goal `‚ä¢ Q`. If `P` and `Q` are sets `intro p` means 'let $p$ be an arbitrary element of $P$'.\n"
"If `P` and `Q` are propositions then `intro p` says 'assume $P$ is true'.\n"
"\n"
"## Details\n"
"\n"
"If your goal is a function or an implication `‚ä¢ P ‚Üí Q` then `intro`\n"
"will always make progress. `intro p` turns\n"
"\n"
"`Goal : P ‚Üí Q`\n"
"\n"
"into\n"
"\n"
"```\n"
"Assumptions:\n"
"p : P\n"
"Goal:\n"
"Q\n"
"```\n"
"\n"
"The opposite tactic to intro is `revert`; given the situation\n"
"just above, `revert p` turns the goal back into `‚ä¢ P ‚Üí Q`.\n"
"\n"
"## Example\n"
"\n"
"If your goal is an implication $P \\implies Q$ then Lean writes\n"
"this as `‚ä¢ P ‚Üí Q`, and `intro p` can be thought of as meaning\n"
"'let $p$ be a proof of $P$', or more informally 'let's assume that\n"
"$P$ is true'. The goal changes to `‚ä¢ Q` and the hypothesis `p : P`\n"
"appears in the local context."
msgstr ""

#: Game.Levels.Intermediate.L02_Two
msgid "## Using apply\n"
"In this problem, you will show that a specific polynomial is continuous. You can do this using\n"
"the basic facts in the right sidebar: that adding continuous functions is continuous,\n"
"likewise multiplying continuous functions remains continuous, constant functions are continuous,\n"
"and the identity function is continuous. The way these lemmas are stated is very general, they work\n"
"for any continuous functions on arbitrary topological spaces, but by using `apply` we can let Lean\n"
"work out the details automatically.\n"
"\n"
"But, how do we talk about the functions themselves?\n"
"The basic method to speak about an unnamed function in Lean makes use of lambda expressions.\n"
"In mathematics we might just write $x ^ 3 + 7$ to describe a polynomial function, leaving it\n"
"implicit that $x$ is the variable.\n"
"In Lean, we use the keyword `fun` to describe a function by placing the name of the variable\n"
"after `fun`.\n"
"So `fun x => x^3 + 7` defines the function that takes input `x` and outputs `x^3 + 7` in Lean.\n"
"\n"
"Watch out! Some of these lemmas have names with a dot and starting with a capital letter\n"
"like `Continuous.add` (these ones prove continuity of a combination of functions)\n"
"and some have an underscore and start with a lowercase letter like `continuous_const`\n"
"(these ones state that some specific function is continuous)."
msgstr ""

#: Game.Levels.Intermediate.L02_Two
msgid "Start with `apply Continuous.add`, you will notice\n"
"that the goal has split into two goals. Try `apply Continuous.add` again and\n"
"see what happens."
msgstr ""

#: Game.Levels.Intermediate.L02_Two
msgid "## Summary\n"
"\n"
"If `h : P ‚Üí Q` is a hypothesis and the goal is `‚ä¢ Q`, then\n"
"`apply h` changes the goal to `‚ä¢ P`.\n"
"\n"
"## Details\n"
"\n"
"If you have a function `h : P ‚Üí Q` and your goal is `‚ä¢ Q`\n"
"then `apply h` changes the goal to `‚ä¢ P`. The logic is\n"
"simple: if you are trying to create a term of type `Q`,\n"
"but `h` is a function that turns terms of type `P` into\n"
"terms of type `Q`, then it will suffice to construct a\n"
"term of type `P`. A mathematician might say: 'We need\n"
"to construct an element of $Q$, but we have a function $h:P \\to Q$\n"
"so it suffices to construct an element of $P$'. Or alternatively\n"
"'we need to prove $Q$, but we have a proof $h$ that $P \\implies Q$\n"
"so it suffices to prove $P$'."
msgstr ""

#: Game.Levels.Intermediate.L03_Three
msgid "In this problem you will see how to prove a statement involving the existential\n"
"quantifier and some inequalities. In the right sidebar you will find some useful\n"
"tactics like `constructor` and `use`, together with some new lemmas."
msgstr ""

#: Game.Levels.Intermediate.L03_Three
msgid "When given a goal that is an `‚àß` (and) of two propositions, the `constructor` tactic\n"
"will produce two goals, one for each side, that can be solved individually."
msgstr ""

#: Game.Levels.Intermediate.L03_Three
msgid "When the goal is to prove an existential `‚àÉ`, we can\n"
"supply the witness (an example that has the desired property)\n"
"using the tactic `use`.\n"
"\n"
"For example :\n"
"If the goal is\n"
"```\n"
"‚ä¢ ‚àÉ n : ‚Ñï, n + 1 = 1\n"
"```\n"
"then we have to take `n` to be zero, so we type `use 0`.\n"
"The remaining goal will then be that\n"
"`0 + 1 = 1`\n"
"which is provable with `zero_add`."
msgstr ""

#: Game.Levels.Intermediate.L04_Four
msgid "## The simplifier\n"
"Up till now we have been using `rewrite` to manually instruct Lean which steps to take, one at a time.\n"
"This is a very useful tool, but after a while you will notice that there are some rewrites that\n"
"will always make things easier when substituted.\n"
"For example, we almost always want to use the fact that multiplying by 1 or adding 0 doesn't\n"
"change things. For this, the `simp` tactic will be very handy.\n"
"\n"
"\n"
"## Commutator identities\n"
"\n"
"In these exercises we will write the proofs of a couple of the identities in\n"
"<https://en.wikipedia.org/wiki/Commutator#Identities_(group_theory)>\n"
"in Lean.\n"
"\n"
"First, we will set up the basic definitions. In World 1 we didn't make any new mathematical\n"
"definitions, we just made use of the natural numbers, propositions, and some lemmas Lean\n"
"already knew about.\n"
"\n"
"```\n"
"def commutator {G : Type*} [Group G]\n"
"(x y : G) : G := x‚Åª¬π * y‚Åª¬π * x * y\n"
"```\n"
"```\n"
"def conjugate {G : Type*} [group G]\n"
"(x y : G) : G := y‚Åª¬π * x * y\n"
"```\n"
"```\n"
"lemma commutator_def {G : Type*} [Group G]\n"
"{x y : G} : [x ; y] = x‚Åª¬π * y‚Åª¬π * x * y := rfl\n"
"```\n"
"```\n"
"lemma conjugate_def {G : Type*} [Group G]\n"
"{x y : G} : y ^ x = x‚Åª¬π * y * x := rfl\n"
"```"
msgstr ""

#: Game.Levels.Intermediate.L04_Four
msgid "## Summary\n"
"\n"
"The `simp` tactic is a high-level tactic which tries\n"
"to prove equalities using facts in its database.\n"
"\n"
"## Details\n"
"\n"
"The `simp` tactic does basic automation.\n"
"For example, some proofs involve a tedious number of rewrites of `add_assoc` and `add_comm`,\n"
"the same is true of `mul_assoc` and `mul_comm` in the case of multiplication.\n"
"We can use `simp` to do this automatically.\n"
"To tell `simp` to use some lemma `h` when simplifying, write `simp[h]`. More generally,\n"
"for `simp` to include additional lemmas `h1`, `h2`, ..., `hn` when simplifying, write\n"
"`simp[h1, h2, ..., hn]`.\n"
"\n"
"### Example:\n"
"If our goal is this:\n"
"```\n"
"‚ä¢ a + b + c + d + e = a + (b + (c + d) + e)\n"
"```\n"
"\n"
"we can solve this with `simp` using `simp[add_assoc]`."
msgstr ""

#: Game.Levels.Intermediate.L05_Five
msgid "In this level you will prove the more complicated\n"
"identity (5) in <https://en.wikipedia.org/wiki/Commutator#Identities_(group_theory)>, called\n"
"the Hall-Witt identity."
msgstr ""

#: Game.Levels.Intermediate.L06_Six
msgid "In this problem you will look at proving that the composition of two continuous maps is\n"
"continuous\n"
"\n"
"Some things you should know:\n"
"- A subset of a space `X` is an element of the type `set X` in Lean\n"
"- The notation for the preimage of a set `U` along a map `f` is `f ‚Åª¬π' U`\n"
"\n"
"You will need to use the tactics intro, rewrite, and apply for this problem!\n"
"And some new lemmas that are in the sidebar for you."
msgstr ""

#: Game.Levels.Intermediate
msgid "Intermediate"
msgstr ""

#: Game.Levels.Intermediate
msgid "Ready for the next World?"
msgstr ""

#: Game
msgid "CAP GAME"
msgstr ""

#: Game
msgid "# CAP GAME\n"
"Learn to use computers to formalize proofs!\n"
"\n"
"# What is this game?\n"
"\n"
"In this game, you will learn the basics of how a program called a *proof assistant* works and use\n"
"it to formalize some mathematical results.\n"
"What does this mean? Instead of writing down proofs in English or any other human language we will\n"
"explain the steps of the proof to the proof assistant using a precise language, similar to a\n"
"programming language in some aspects.\n"
"The advantage of doing this is that the computer can then keep track of the proof for us, and tell\n"
"us if we make any steps that aren't logically valid, computers are very good at understanding logic\n"
"after all!\n"
"Other than needing to use specific commands to explain the proof steps, we can work on proofs like\n"
"usual, using definitions and already established facts to show new results.\n"
"The proof assistant will completely keep track of what facts we know so far, and show us what else\n"
"needs to be shown to finish the current proof. Importantly, it won't let us show something that\n"
"doesn't logically follow from what we have proved so far.\n"
"\n"
"This is a very literal sort of computer assisted proof, we are using a computer to step through and\n"
"understand individual steps in a proof.\n"
"Later we will see how the assistant can do more than just follow our instructions, it can also\n"
"search for us and find useful facts we might want to use. Lean can even complete some moderately\n"
"difficult or tricky proofs on its own, using proof methods based on pre-defined rules.\n"
"This saves us time thinking about details in some situations, without losing any confidence in the\n"
"correctness of the result, and in some cases we can even learn from the proofs Lean finds!\n"
"\n"
"\n"
"To get started click on the first world, the circle labeled Intro, on the right.\n"
"You can use this menu to navigate as you try more of the problems.\n"
"Have fun!\n"
"\n"
"If you experience any technical issues with the game please let us know on the canvas page."
msgstr ""

#: Game
msgid "The CAP Game, was created as material for the course computer assisted proofs at the Vrije Universiteit Amsterdam.\n"
"The original version can be found here https://alexjbest.github.io/CAP-game/.\n"
"Based on templates from Imperial College London and Universitat Aut√≤noma de Barcelona.\n"
"This version is adapted to Lean 4 using the Lean4 Game Engine.\n"
"Lean is a proof assistant being developed at Microsoft Research."
msgstr ""

#: Game
msgid "Game Template"
msgstr ""

#: Game
msgid "You should use this game as a template for your own game and add your own levels."
msgstr ""
